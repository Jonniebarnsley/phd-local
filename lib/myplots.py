import numpy as np
import pandas as pd
import xarray as xr
import cartopy.crs as ccrs
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.ticker as mticker
from itertools import product
from local.libs.utils import round_sig_figs

def spatialPlot(ax: plt.Axes, da: xr.DataArray, **kwargs) -> None:

    # centre on South Pole
    x = da.x
    y = da.y
    x = x - x.mean()
    y = y - y.mean()

    kw = dict(central_latitude=-90, central_longitude=0, true_scale_latitude=-70)
    im = ax.pcolormesh(x, y, da, transform = ccrs.Stereographic(**kw), **kwargs)
    ax.coastlines(lw=0.2)

    return im

def ts(
        df: pd.DataFrame,
        ax: plt.axis,
        **kwargs
):
    ax.plot(df, **kwargs)

def ts_with_hist(
        df: pd.DataFrame,
        ax1: plt.axis,
        ax2: plt.axis,
        ylabel: str = None, 
        ylim: float = None, 
        title: str = '', 
        bin_width: float = 1.,
        color: str = 'black',
        lw: float = 0.3,
        alpha: float = 0.3, 
        **kwargs
        ):

    '''
    plots ensemble timeseries using summary csvs generated by Calculate_ensemble_SLC.py. 
    Includes a histogram of final values aligned with timeseries axis.

    inputs:
        - data: pandas dataframe with columns as run numbers and rows as years
        - ylab: label for timeseries y axis
        - **kwargs: key word arguments for timeseries axis
    '''

    #fig, ax = plt.subplots(ncols=2, figsize=(8, 5), sharey=True, width_ratios=[3, 1], dpi=600)

    # plot timeseries
    ax1.plot(
        df,
        color=color,
        alpha=alpha,
        lw=lw,
        **kwargs
        )
    
    # plot histogram
    slc = df.iloc[-1]
    ymin = np.floor(slc.min())
    ymax = np.ceil(slc.max())
    bins = np.arange(ymin, ymax+bin_width, bin_width)
    ax2.hist(
        slc,
        bins = bins,
        orientation='horizontal',
        color='black',
    )

    # timeseries axis options
    xmax = round_sig_figs(slc.name)
    offset = xmax/50
    ax1.set_xlim([-offset, xmax])
    ax1.set_ylim(ylim)
    ax1.set_xlabel('Time ($yrs$)')
    ax1.set_ylabel(ylabel)
    ax1.set_title(title)
    ax1.tick_params(axis='both', direction='in')
    ax1.hlines(0, 0, 10_000, lw=0.5, color='red') 

    # histogram axis options
    ax2.set_xlabel('Density')
    ax2.tick_params(top=True, labeltop=True, bottom=False, labelbottom=False)
    ax2.tick_params(axis='y', color='none')
    #ax2.set_xticks([])
    

    #fig.subplots_adjust(wspace=0.05)

def sensitivity(df, output, mask=None, relabel={}, colors=None, **kwargs):

    parameters = df.columns
    if colors:
        mpl.rcParams['axes.prop_cycle'] = mpl.cycler(color=colors) 


    # account for weird indexing, ensures groupby works correctly
    N = len(output)
    df.index = range(N)
    output.index = range(N)

    fig, axes = plt.subplots(ncols=3, nrows=2, figsize=(10, 5), dpi=600)

    for param, ax in zip(parameters, axes.flatten()):

        if mask is None:
            ax.scatter(df[param], output, **kwargs)
        else:
            for (_, param_group), (_, output_group) in zip(df.groupby(mask), output.groupby(mask)):
                ax.scatter(param_group[param], output_group, **kwargs)

        ax.set_xlabel(relabel.get(param, param))
        formatter = mticker.ScalarFormatter(useMathText=True)
        ax.xaxis.set_major_formatter(formatter)
        ax.ticklabel_format(style='sci', scilimits=(-2, 2))

    for i, j in product(range(3), range(2)):
        if i == 0:
            axes[j][i].set_ylabel('sea level contribution ($m$)')
        else:
            axes[j][i].tick_params(axis='y', which='both', left=False, labelleft=False)

    axes[1][2].set_axis_off()
    fig.subplots_adjust(hspace=0.4, wspace=0.1)

    return fig

def save(fig: mpl.figure.Figure, name: str) -> None:

    '''
    Saves a figure as a pdf and png in the appropriate folders
    '''

    fig.savefig(f'plots/pdf/{name}.pdf', format='pdf')
    fig.savefig(f'plots/png/{name}.png', format='png')